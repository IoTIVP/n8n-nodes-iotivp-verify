# IoTIVP Verify (Gateway) — SPEC

## 1. Webhook — “IoT Sensor Ingest”

The workflow begins with an HTTP Webhook receiving packets from IoT devices.

Example Input:

    {
      "device_id": 42,
      "packet_hex": "0102a10f7fff93b2"
    }

The content of packet_hex does not matter in Fake-Verifier Mode, but it mimics real binary transmission.

## 2. IoTIVP Verify (Gateway) — Fake-Verifier Mode

The IoTIVP Verify (Gateway) node receives the incoming item and attaches two simulated objects:

    - core_packet      (IoTIVP-Core format)
    - verify_result    (IoTIVP-Verify validation output)

These values are generated in Fake-Verifier Mode and do not rely on real binary parsing or cryptographic hashing.

Example Output Structure:

    {
      "device_id": 42,
      "packet_hex": "0102a10f7fff93b2",

      "core_packet": {
        "header": 1,
        "timestamp": 1732212000,
        "device_id": 42,
        "nonce": 7,
        "fields": {
          "temperature": 25.4,
          "humidity": 52,
          "battery": 91
        },
        "hash": "f4a291bc",
        "_meta": {
          "mode": "fake-verifier",
          "packet_hex_seen": true
        }
      },

      "verify_result": {
        "valid": true,
        "integrity_score": 92,
        "flags": {
          "hash_mismatch": false,
          "timestamp_expired": false,
          "nonce_reuse": false,
          "value_out_of_range": []
        },
        "_meta": {
          "mode": "fake-verifier"
        }
      }
    }

This simulated output establishes the expected IoTIVP-Core and IoTIVP-Verify formats long before real decoding and verification logic are implemented.

## 3. IF Node — “Integrity OK?”

The workflow evaluates the integrity of the incoming IoT packet using the score generated by the IoTIVP Verify (Gateway) node.

Integrity Condition:

    verify_result.integrity_score >= 80

Branch Logic:

    - TRUE  → Packet is considered trusted and moves into the Trusted Branch.
    - FALSE → Packet is considered untrusted and moves into the Untrusted Branch.

In Fake-Verifier Mode:
    - integrity_score is always 92.
    - Therefore, all packets flow through the TRUE (trusted) branch.

This condition will become meaningful once real verification logic is implemented.

## 4. Trusted Branch — Save or Use Sensor Data

High-integrity packets flow into the trusted pipeline. These packets are considered valid, untampered, and safe to use in downstream automation.

Possible downstream actions:

    - Append to Google Sheets
    - Insert into PostgreSQL / MySQL
    - Publish to MQTT for robotics or edge devices
    - Forward to dashboards or digital twins
    - Trigger automation based on clean, verified telemetry

Example trusted row (Google Sheets):

    | timestamp   | device_id | temperature | humidity | battery | integrity_score |
    |-------------|-----------|-------------|----------|---------|-----------------|
    | 1732212000  | 42        | 25.4        | 52       | 91      | 92              |

This branch represents the final destination for verified, high-confidence IoT data that passes all integrity checks.

## 5. Untrusted Branch — Quarantine or Alert

Packets that fail integrity validation (once real Verify logic is active) are routed into the Untrusted Branch. These packets may indicate tampering, corruption, replay attempts, or device malfunction.

Possible downstream actions:

    - Send an alert via Telegram / Slack / Email
    - Log packet details to a "Quarantine" database or Google Sheet
    - Trigger a forensic or incident-response workflow
    - Store raw packet data for later investigation
    - Notify system operators or security teams

Purpose of this branch:

    - Prevent unverified or suspicious data from influencing automations
    - Create a clean separation between trusted and untrusted telemetry
    - Provide early detection of anomalous or malicious device activity

This branch becomes mission-critical when real verification is implemented, as it contains all packets that cannot be trusted.

## 6. Purpose Summary

This example workflow demonstrates how IoTIVP Verify (Gateway) functions as a trust-first layer inside an n8n automation environment.

Key objectives:

    - Establish a clear separation between trusted and untrusted IoT data
    - Provide a standardized structure for IoTIVP-Core and IoTIVP-Verify output
    - Enable early testing and workflow design using Fake-Verifier Mode
    - Offer a portfolio-ready demonstration of IoT data integrity enforcement
    - Prepare downstream systems (databases, dashboards, robotics, alerts) to rely on verified data

As real decoding and verification logic is implemented, this workflow will evolve into a full integrity pipeline. The structure shown here remains stable, ensuring long-term compatibility with future IoTIVP-Core, IoTIVP-Binary, and IoTIVP-Verify releases.

This marks the first canonical integration pattern for IoTIVP inside n8n.
